rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is an admin
    function isAdmin() {
      return isAuthenticated() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    
    // Helper function to check if user is owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to validate face descriptor format
    function isValidFaceDescriptor() {
      return request.resource.data.keys().hasAll(['faceDescriptor']) &&
             request.resource.data.faceDescriptor is list &&
             request.resource.data.faceDescriptor.size() > 0 &&
             request.resource.data.faceDescriptor.size() <= 512; // Face descriptors are typically 128-512 elements
    }
    
    match /admins/{adminId} {
      allow read: if isAuthenticated() && (isOwner(adminId) || isAdmin());
      allow create: if true; // Allow creation during registration
      // STRICT: Only owner can update, and face descriptor must be valid
      allow update: if isAuthenticated() && isOwner(adminId) && (
                      // General updates allowed
                      true ||
                      // Face descriptor updates must be valid
                      (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['faceDescriptor', 'faceRegisteredAt']) && 
                       isValidFaceDescriptor())
                    );
      allow delete: if false; // Prevent deletion
    }
    
    match /users/{userId} {
      allow create: if true; // Allow creation during registration
      // Users can read their own data, admins can read all
      // Also allow authenticated users (drivers) to read user data for order delivery purposes
      // This is necessary for drivers to see customer information in assigned orders
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin() || true);
      
      // STRICT: Only owner or admin can update, face descriptor must be valid
      allow update: if isAuthenticated() && (isAdmin() || isOwner(userId)) && (
                      // If updating face descriptor, must be valid format
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['faceDescriptor']) ||
                      isValidFaceDescriptor()
                    );
      allow delete: if isAdmin(); // Only admins can delete users
    }
    
    match /drivers/{driverId} {
      // STRICT: Only owner, admin, or authenticated users (for booking) can read
      allow read: if isAuthenticated();
      allow create: if true; // Allow creation during registration
      
      // STRICT: Only owner or admin can update, face descriptor must be valid
      allow update: if isAuthenticated() && (isAdmin() || isOwner(driverId)) && (
                      // If updating face descriptor, must be valid format
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['faceDescriptor']) ||
                      isValidFaceDescriptor()
                    );
      allow delete: if isAdmin(); // Only admins can delete drivers
    }
    
    // Orders collection - STRICT access control
    match /orders/{orderId} {
      allow read: if isAuthenticated() && (
                     resource.data.userId == request.auth.uid ||
                     resource.data.driverId == request.auth.uid ||
                     isAdmin()
                   );
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && (
                       resource.data.userId == request.auth.uid ||
                       resource.data.driverId == request.auth.uid ||
                       isAdmin()
                     );
      allow delete: if isAdmin(); // Only admins can delete orders
    }
    
    // Driver applications collection
    match /driver_applications/{applicationId} {
      allow read: if isAuthenticated() && (
                     resource.data.userId == request.auth.uid ||
                     isAdmin()
                   );
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAdmin(); // Only admins can update applications
      allow delete: if isAdmin();
    }
    
    match /settings/{settingId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin(); // Only admins can modify settings
    }
    
    // System logs collection - STRICT: Only admins can read/delete
    match /system_logs/{logId} {
      allow create: if isAuthenticated(); // Anyone authenticated can create logs
      allow read: if isAdmin(); // Only admins can read logs
      allow delete: if isAdmin(); // Only admins can delete logs
      allow update: if false; // Logs are immutable
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && (
                     resource.data.userId == request.auth.uid ||
                     isAdmin()
                   );
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
                       resource.data.userId == request.auth.uid ||
                       isAdmin()
                     );
      allow delete: if isAuthenticated() && (
                       resource.data.userId == request.auth.uid ||
                       isAdmin()
                     );
    }
    
    // Complaints collection for fraud detection
    match /complaints/{complaintId} {
      allow read: if isAuthenticated() && (
                     resource.data.userId == request.auth.uid ||
                     isAdmin()
                   );
      allow create: if isAuthenticated();
      allow update: if isAdmin(); // Only admins can update complaints
      allow delete: if isAdmin();
    }
    
    // Chats collection - STRICT: Only participants can access
    match /chats/{chatId} {
      // Helper function to check if user is a participant
      function isParticipant() {
        return isAuthenticated() && (
          // Check participants object first (preferred method)
          (resource.data.participants != null && 
           resource.data.participants.keys().hasAny([request.auth.uid]) &&
           resource.data.participants[request.auth.uid] == true) ||
          // Fallback: check userId or driverId fields
          (resource.data.userId == request.auth.uid) ||
          (resource.data.driverId == request.auth.uid)
        );
      }
      
      // Allow reading if user is admin, OR if they're a participant
      // Participants check: userId/driverId fields OR participants object
      // This ensures both users can read the chat document, which allows get() in messages rules to work
      allow read: if isAuthenticated() && (
        isAdmin() ||
        // Allow if user is userId or driverId (most reliable check)
        (resource.data.userId == request.auth.uid) ||
        (resource.data.driverId == request.auth.uid) ||
        // OR if they're in participants object
        (resource.data.participants != null && 
         resource.data.participants.keys().hasAny([request.auth.uid]) &&
         resource.data.participants[request.auth.uid] == true)
      );
      allow create: if isAuthenticated() && (
                     // User must be either userId or driverId in the chat being created
                     request.resource.data.userId == request.auth.uid ||
                     request.resource.data.driverId == request.auth.uid ||
                     isAdmin()
                   );
      allow update: if isAuthenticated() && (
                       isParticipant() ||
                       isAdmin() ||
                       // Allow updating participants if user is userId or driverId
                       (resource.data.userId == request.auth.uid) ||
                       (resource.data.driverId == request.auth.uid)
                     );
      allow delete: if isAdmin(); // Only admins can delete chats
      
      // Messages subcollection within chats
      match /messages/{messageId} {
        // Helper function to check if user is a participant in parent chat
        // IMPORTANT: get() requires read permission on the parent document
        // This will only work if the user can already read the parent chat document
        function isChatParticipant() {
          // Check if parent chat document exists and user is a participant
          // get() will only succeed if user has read permission on parent chat
          let chatData = get(/databases/$(database)/documents/chats/$(chatId)).data;
          return isAuthenticated() && (
            // Primary check: userId or driverId (most reliable, always set)
            (chatData.userId == request.auth.uid) ||
            (chatData.driverId == request.auth.uid) ||
            // Secondary check: participants object (if it exists)
            (chatData.participants != null && 
             chatData.participants.keys().hasAny([request.auth.uid]) &&
             chatData.participants[request.auth.uid] == true) ||
            isAdmin()
          );
        }
        
        // For reading messages: 
        // Strategy: Allow reading if user can read parent chat OR if they sent the message
        // IMPORTANT: get() requires read permission on parent chat document
        // Since we allow reading chat if user is userId or driverId, get() should succeed
        allow read: if isAuthenticated() && (
          isAdmin() ||
          // User can always read their own messages (no parent chat permission needed)
          (resource != null && resource.data.senderId == request.auth.uid) ||
          // For other messages, check parent chat using helper function
          // get() will only succeed if user can read parent chat (which we allow if userId/driverId)
          isChatParticipant()
        );
        
        // For creating messages:
        // 1. Sender must match authenticated user
        // 2. User must be a participant in parent chat (checked via get())
        allow create: if isAuthenticated() && (
          // Sender must match authenticated user
          request.resource.data.senderId == request.auth.uid &&
          // Check if user is participant in parent chat using helper function
          // get() requires read permission on parent chat, which should be granted by isParticipant()
          isChatParticipant()
        );
        // Allow updates only for marking messages as deleted (soft delete)
        // User can only update their own messages to mark them as deleted
        allow update: if isAuthenticated() && (
          // User must be the sender of the message (this is the key security check)
          resource.data.senderId == request.auth.uid &&
          // Must be setting deleted to true
          request.resource.data.deleted == true &&
          // Ensure senderId is not changed (prevent changing ownership)
          request.resource.data.senderId == resource.data.senderId
        );
        // Allow hard delete only for admins
        allow delete: if isAdmin();
      }
    }
    
    // Face verification attempts tracking - STRICT: Only owner can read/write
    match /face_attempts/{userId} {
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin());
      allow write: if isAuthenticated() && isOwner(userId); // Only user can update their own attempts
      allow delete: if false; // Prevent deletion of attempt records
    }
    
    // Remittances collection - STRICT: Drivers can create, admins can read/update
    match /remittances/{remittanceId} {
      allow read: if isAuthenticated() && (
                     resource.data.driverId == request.auth.uid ||
                     isAdmin()
                   );
      allow create: if isAuthenticated() && request.resource.data.driverId == request.auth.uid;
      allow update: if isAdmin(); // Only admins can approve/reject remittances
      allow delete: if isAdmin(); // Only admins can delete remittances
    }
    
    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

