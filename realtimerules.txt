{
  "rules": {
    // Face descriptors - STRICT: Only owner can access their own descriptor
    "faceDescriptors": {
      "$userId": {
        ".read": "$userId === auth.uid",
        ".write": "$userId === auth.uid",
        ".validate": "newData.hasChildren(['descriptor', 'registeredAt']) && 
                      newData.child('descriptor').isNumber() &&
                      newData.child('registeredAt').isString()"
      }
    },
    
    // Users - STRICT: Only owner can read/write their own data
    "users": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid",
        ".validate": "newData.hasChildren(['email', 'role'])"
      }
    },
    
    // Orders - STRICT: Only owner (user or driver) can access
    "orders": {
      "$orderId": {
        ".read": "auth != null && (
                     data.child('userId').val() === auth.uid || 
                     data.child('driverId').val() === auth.uid
                   )",
        ".write": "auth != null && (
                     data.child('userId').val() === auth.uid || 
                     data.child('driverId').val() === auth.uid
                   )",
        ".validate": "newData.hasChildren(['userId', 'serviceType', 'status', 'createdAt']) &&
                      newData.child('status').isString() &&
                      newData.child('createdAt').isNumber()"
      }
    },
    
    // Chats - STRICT: Only participants can access
    "chats": {
      "$chatId": {
        ".read": "auth != null && data.child('participants').child(auth.uid).exists()",
        ".write": "auth != null && data.child('participants').child(auth.uid).exists()",
        ".validate": "newData.hasChildren(['participants', 'createdAt'])"
      }
    },
    
    // Messages - STRICT: Only chat participants can access
    "messages": {
      "$messageId": {
        ".read": "auth != null",
        ".write": "auth != null && newData.child('senderId').val() === auth.uid",
        ".validate": "newData.hasChildren(['senderId', 'text', 'timestamp']) &&
                      newData.child('senderId').isString() &&
                      newData.child('text').isString() &&
                      newData.child('timestamp').isNumber()"
      }
    },
    
    // Payments - STRICT: Only owner can access
    "payments": {
      "$paymentId": {
        ".read": "auth != null && data.child('userId').val() === auth.uid",
        ".write": "auth != null && data.child('userId').val() === auth.uid",
        ".validate": "newData.hasChildren(['userId', 'amount', 'status', 'createdAt'])"
      }
    },
    
    // Driver locations - Public read for tracking, STRICT: Only driver can write their own
    "driverLocations": {
      "$driverId": {
        ".read": "auth != null",
        ".write": "$driverId === auth.uid",
        ".validate": "newData.hasChildren(['latitude', 'longitude', 'timestamp']) &&
                      newData.child('latitude').isNumber() &&
                      newData.child('longitude').isNumber()"
      }
    },
    
    // Services - Public read only, no writes
    "services": {
      ".read": "auth != null",
      ".write": false
    },
    
    // Face verification attempts - STRICT: Only owner can access
    "faceAttempts": {
      "$userId": {
        ".read": "$userId === auth.uid",
        ".write": "$userId === auth.uid",
        ".validate": "newData.hasChildren(['verificationAttempts', 'registrationAttempts', 'lastAttempt'])"
      }
    },
    
    // Default deny all other paths (STRICT)
    "$other": {
      ".read": false,
      ".write": false
    }
  }
}
